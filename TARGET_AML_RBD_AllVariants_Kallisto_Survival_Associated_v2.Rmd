---
title: 'Surivival Analysis of Fusion Groups in Ribodepleted RNAseq'
author: "Jenny Smith"
date: "April 16, 2019"
output: html_document
---


#Set-Up

```{r setup}
library(knitr)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())


knitr::opts_chunk$set(tidy.opts=list(width.cutoff=50),
                      tidy=TRUE, fig.align='center', fig.height=5,
                      fig.width=8, dpi = 600)

options(stringsAsFactors = FALSE)
options(expressions = 500000)

options(stringsAsFactors = FALSE,bitmapType = 'cairo')
# grDevices::X11.options(type='cairo')
```

```{r message = FALSE, warning=FALSE}
library(stringr)
library(magrittr)
library(dplyr)
library(tibble)
library(tidyr)


library(edgeR)
library(limma)
library(survival)

library(RColorBrewer)
library(gridExtra)
library(GGally)
library(ggplot2)

# library(DeGSEA) #my custom build R package that used to be imported through `source`
```

```{r}
# install.packages("glmnet_3.0.tar.gz", repos=NULL, type='source', 
#                  lib="/home/jlsmith3/R/x86_64-pc-linux-gnu-library/")
```

# Define Functions

```{r}
rmDups <- function(count.matrix, ID.map, matrix.class=TRUE,rowname.GeneSym=TRUE){
  
  df <- count.matrix %>%
    as.data.frame() %>%
    rownames_to_column("gene_id") %>%
    left_join(., ID.map, by=c("gene_id")) %>% 
    select(gene_id, gene_name, everything()) %>%
    filter(!grepl("_PAR_", gene_id)) #specific to gencode refs
  
  
  dup <- df$gene_name[which(duplicated(df$gene_name))]
  ddf <- df %>%
    filter(gene_name %in% dup) %>% 
    arrange(gene_name)%>% 
    mutate(Variance=genefilter::rowVars(select(., -gene_id, -gene_name))) %>%

    group_by(gene_name) %>% 
    mutate(High.Variance=Variance==max(Variance)) %>% 
    ungroup() %>% 
    
    filter(High.Variance)  %>%
    filter(!duplicated(gene_name))#if variance tied, pick first one
    
  
  if(rowname.GeneSym){
    rmDups.df <- df %>% 
        filter(! gene_name %in% dup) %>% 
        bind_rows(.,ddf) %>%
        select(everything(),-gene_id, -Variance,-High.Variance) %>%
        column_to_rownames("gene_name")
  }else{
    rmDups.df <- df %>% 
        filter(! gene_name %in% dup) %>% 
        bind_rows(.,ddf) %>%
        select(everything(),-gene_name, -Variance,-High.Variance) %>%
        mutate(gene_id=gsub("\\.[0-9]{1,2}", "", gene_id)) %>% 
        column_to_rownames("gene_id")
  }

  if(matrix.class){
    rmDups.df <- data.matrix(rmDups.df)
  }
  
  return(rmDups.df)
}  
```

```{r}
cox_reg <- function(gene_name,CDE,variables=NULL, OS=FALSE){
  
  if(OS){
    KM <- Surv(time=CDE$OS.time..days., event = CDE$OS.ID)
  }else{
     KM <- Surv(time=CDE$EFS.time..days., event = CDE$Event.ID)
  }
 
  
  if(is.null(variables)){
    variables <- gene_name
  }else{
    variables <- paste(c(gene_name,variables),collapse = "+")
  }
  
  formula <- as.formula(paste("KM",variables, sep=" ~ ")) 

  c1 <- coxph(formula, data=CDE)
  tab <- coxSummaryTable(c1)
  
  return(tab)
}
```

```{r}
plots <- function(Model.Comparison.df, Gene.Col,log=FALSE, type="wfall"){
  library(ggpubr)
  if(!log){Model.Comparison.df[,Gene.Col] <- 2^(Model.Comparison.df[,Gene.Col]-1)} #non-log2
  
  if(type=="wfall"){
   p <- ggbarplot(Model.Comparison.df, 
            x = "USI", y = Gene.Col,
          fill = "lnc.Percentile.Groups",               # change fill color by cyl
          color = "lnc.Percentile.Groups",            # Set bar border colors to white
          palette = "jco",            # jco journal color palett. see ?ggpar
          sort.val = "asc",           # Sort the value in dscending order
          sort.by.groups = FALSE,      # Sort inside each group
          x.text.angle = 90,           # Rotate vertically x axis texts
          facet.by = "Set",
          scales="free") + 
    theme(axis.text.x=element_blank())
  }
  
  if(type=="box"){
   p <- ggboxplot(Model.Comparison.df, 
          x = "lnc.Percentile.Groups", y = Gene.Col, 
          fill = "lnc.Percentile.Groups",               
          palette = "jco",            
          sort.val = "asc",           
          sort.by.groups = FALSE,      
          x.text.angle = 90,           
          facet.by = "Set",
          scales="fixed") + 
    theme(axis.text.x=element_blank())
  }
  
  return(p)
}
```

```{r}
cox_glmnet_workflow <- function(CDE.train,targets,IDmap,
                                std=FALSE,N.Groups=5,
                                oneSE=FALSE,
                                seed_num=2019,
                                CDE.validation1=NULL,
                                CDE.validation2=NULL){
  
  suppressPackageStartupMessages(library(glmnet,lib.loc = "/home/jlsmith3/R/x86_64-pc-linux-gnu-library"))
  #CDE.train has  patients as rows, surivival data and all genes expression values as columns.
  #targets is a character vector with the column names of the genes of interest that will be included in the glmnet fit. 
  #lncRNAs is IDmap for ENSG lncRNA IDs to gene name with biotype. 
  #CDE.validation1 is the "test set" has  patients as rows, surivival data and all genes expression values as columns.
  #CDE.validation2 has  patients as rows, surivival data and all genes expression values as columns.
      
      
      sparsemat_to_df <- function(coef){
        #sparsemat is a sparce matrix from the output of predict(.,type="coefficients")
        coef <- data.frame(coef=coef[,1]) %>%
          rownames_to_column("gene") %>%
          filter_all(all_vars(. != 0))
        return(coef)
      }
      
      #Derive the AIC for model 
      #https://stats.stackexchange.com/questions/25817/is-it-possible-to-calculate-aic-and-bic-for-lasso-regression-models
      AIC.stat <- function(fit,lambda.val){
        idx <- which(fit$lambda == lambda.val) #select which model to get AIC from
        tLL <- fit$nulldev - deviance(fit)[idx]
        k <- fit$df[idx]
        n <- fit$nobs
        AICc <- -tLL+2*k+2*k*(k+1)/(n-k-1)
        return(AICc)
        # BIC <- log(n)*k - tLL
      }

      
      #character vector of input data sets
      sets <- c("Train","Validation1")
      addl <- c(!is.null(CDE.validation2))
      if(all(addl)){sets <- c(sets,"Validation2")}
      
      #grid of lambda values to test.
      grid <- 10^ seq(10,-2, length=100)
      
      
      ## Training 
      x.train <- CDE.train %>% 
        filter(EFS.time..days. != 0) %>% # time cannot be zero 
        select(all_of(targets)) %>%  #pull(sig.ures,Variable)
        as.matrix()
      
      y.train <- CDE.train %>% 
        filter(EFS.time..days. != 0) %>% # time cannot be zero 
        select(time="EFS.time..days.", status="Event.ID") %>%
        as.matrix()
      
      # dim(y.train)
      # dim(x.train)
      
      mod <- glmnet(x=x.train,
                    y=y.train,
                    family = "cox",
                    standardize = std,
                    lambda = grid)
      
      # plot(mod)
      
      #Seed was set at 2019 
      set.seed(seed_num)
      cv.lambda <- cv.glmnet(x=x.train, y=y.train,
                             family = "cox",
                             standardize = std,
                             lambda = grid,
                             nfolds = nrow(x.train),
                             type.measure = "deviance")
      
      if(oneSE){
        lambda <- cv.lambda$lambda.1se
      }else{
        lambda <- cv.lambda$lambda.min
      }
      
      coef.trainingMod <- predict(mod, type="coefficients", s=lambda)
      nonZero.train <- sparsemat_to_df(coef.trainingMod) %>% 
        arrange(desc(coef)) %>% 
        left_join(., IDmap, by=c("gene"="gene_id"))
      
      ## Testing 
      x.test <- CDE.validation1 %>% 
        filter(EFS.time..days. != 0) %>% # time cannot be zero 
        select(targets) %>% 
        as.matrix()

      
      #predict the survival outcome. Returns relative risk of each patient
      pred.outcome <- predict(mod, 
                              newx = x.test,
                              type="response",
                              s=lambda) 
  
      #Model AIC 
      AIC <- AIC.stat(fit = cv.lambda$glmnet.fit, lambda.val=lambda)
      
      
      ##Apply the Score 
      rm.genes <- setdiff(grep("^ENSG", colnames(CDE.train), value=TRUE),
                          nonZero.train$gene) #genes NOT selected in Model
      Model.Comparison.df <- CDE.train %>% 
        bind_rows(CDE.validation1,CDE.validation2) %>%
        select(USI,Set,everything(),-rm.genes) %>%  
        select(USI,Set,nonZero.train$gene,everything()) %>% #ensure CORRECT ORDER of gene expression columns 
        mutate(lnc.Score=apply(dplyr::select(., starts_with("ENSG")), 1,
                               function(x) sum(x*nonZero.train$coef)))#apply the score calculation 
      
      #Exception handling if score ends up having very low variability.
      N=N.Groups
      perc.labs <- function(N){paste0("q",1:N)}
      e <- try(group_by(Model.Comparison.df, Set) %>% 
                  mutate(TEST=gtools::quantcut(lnc.Score, q=N, na.rm=FALSE, labels=perc.labs(N))), 
               silent = TRUE)
      if(inherits(e,"try-error")){N=3}
    
      
      #Create Median/Percentile Groups
      Model.Comparison.df <- Model.Comparison.df %>%
        group_by(Set) %>% 
        mutate(lnc.Median.Groups=factor(ifelse(lnc.Score >= median(lnc.Score), "high", "low"),
                                        levels=c("low", "high")), 
               lnc.Percentile.Groups=as.factor(gtools::quantcut(lnc.Score, q=N, na.rm=FALSE, 
                                                        labels=perc.labs(N)))) %>%
        arrange(desc(lnc.Score)) %>%
        ungroup() %>% 
        mutate(Set=factor(Set, levels = sets))
      
      #Model formulas
      y1 <- c("OS.time..days.","OS.ID")
      y2 <- c("EFS.time..days.","Event.ID")
      make_form <- function(response,covariate){ 
        as.formula(paste0("Surv(", response[1],"/365.25", ",",response[2], ")~ ",covariate))
      }
      
      #Examine how the model score delineates risk groups.
      error.metrics <- Model.Comparison.df %>%
        group_by(Set) %>%
        do(cox.OSmedianGroups=coxph(make_form(y1, "lnc.Median.Groups"), data = .),
           cox.EFSmedianGroups=coxph(make_form(y2, "lnc.Median.Groups"), data = .),
           
           cox.OSpercentileGroups=coxph(make_form(y1, "lnc.Percentile.Groups"), data = .),
           cox.EFSpercentileGroups=coxph(make_form(y2, "lnc.Percentile.Groups"), data = .),
           
           
           cox.OScontinuous=coxph(make_form(y1, "lnc.Score"), data = .),
           cox.EFScontinuous=coxph(make_form(y2, "lnc.Score"), data = .),
           
           KM.OS.Med=SurvivalPlot(survfit(make_form(y1, "lnc.Median.Groups"), data=.), #survival plots
                              LegendTitle = "OS",
                              timeUnit = "Years",
                              colors = c("high"="red", "low"="dodgerblue")),
           KM.EFS.Med=SurvivalPlot(survfit(make_form(y2, "lnc.Median.Groups"), data=.),
                               LegendTitle="EFS",
                               timeUnit= "Years",
                               colors= c("high"="red", "low"="dodgerblue")), 
           
           KM.OS.Perc=SurvivalPlot(survfit(make_form(y1, "lnc.Percentile.Groups"), data=.), #survival plots
                              LegendTitle = "OS",
                              timeUnit = "Years",
                              colors = "gg.def"),
           KM.EFS.Perc=SurvivalPlot(survfit(make_form(y2, "lnc.Percentile.Groups"), data=.),
                               LegendTitle="EFS",
                               timeUnit= "Years",
                               colors= "gg.def")) %>% 
        ungroup() %>% 
        mutate(Set=factor(Set, levels=sets)) %>% 
        arrange(Set)
  
  #Final results 
  res <- list(mod,cv.lambda,nonZero.train,Model.Comparison.df,error.metrics,AIC)  
  names(res) <- c("training.model","cv.lambda","nonZero.train.coef","Model.Comparison.df","error.metrics","AIC")
  
  return(res)    
}


#Collapse the error metrics tibble into a dataframe
extract_metrics_df <- function(error.metrics.tibble,V=FALSE, V2=NULL){
  Names <- names(error.metrics.tibble[2:7])
  #character vector of input data sets
  sets <- c("Train","Validation1","Validation2")
  res <- lapply(Names, 
       function(x) lapply(error.metrics.tibble[[x]], coxSummaryTable) %>% 
         lapply(., function(x) mutate(x,Levels=nrow(x))) %>%
         bind_rows() %>% 
         mutate(Comparison=x,Set=rep(sets, each=unique(Levels)))) %>% 
  bind_rows() %>% 
  select(Comparison, Set, everything())
  
  return(res)
}
```

```{r}
#Function for Limma Voom differential expression 
voom_DE <- function(expnData, pheno,ref,percent,
                    logCPM=FALSE,trend=FALSE,
                    normalization=FALSE,GOI=NULL,
                    eBayesRobust=FALSE,
                    lmMethod="ls") {
  # expnData is a matrix or data frame with the raw counts. Patient IDs as colnames, genes as rownames
  # pheno is a character vector with patient IDs as names, and the status for each in each group(eg pos,neg)
  #ref is a chacter vector of the reference level for DE. for example ref="No". 
  # percent is the fraction (0-1 numberic) of AML samples to include when setting an expression threshold. eg 5% of AMLs, percent=0.05. 
  #trend is for using limma trend method with log2 CPMs
  #normalization is for an extra method of normalization such as quantile if necessary. should be either FALSE or "qt" so far
  #GOI is a character vector of genes (or numeric vector of row indices) of interest to subset at the end. keeps BH adjuted p-values more accurate. 

  library(limma)
  library(edgeR)
  
  expnData <- expnData[,match(names(pheno), colnames(expnData))] ##ensure correct order
  
  if (!all(complete.cases(expnData))){
    print("Names DO NOT match in between phenovector and colnames of expression matrix")
    return(list(expnData=expnData,pheno=pheno))
  }
  
  groups <- unique(pheno)
  groups <- c(groups[groups != ref], ref) #order so that reference is second 
  pheno.f <- factor(pheno, levels=groups)
  dge <- DGEList(counts = expnData, group = pheno.f)
  
  AML <- ! grepl("BM[0-9]|R[O0][0-9]", colnames(expnData))
  AMLsamples <- sum(AML)
  
  #This is to allow for 2/3 samples must have 1 cpm. Since 3 is the minimum # of samples I will allow for DE analysis. 
  keep.dge <- rowSums(cpm(dge)[,AML] >= 1) >= max(2,(percent*AMLsamples)) #X% of AML samples has cpm of at least 1 for a gene
 
  dge <- dge[keep.dge,] #subset for those genes with cmp >= 1 per gene in AML samples
  dge <- calcNormFactors(dge) #Do TMM normalization
  
  design <- model.matrix(~0 + pheno.f, data=dge$samples)#~0 means no intercept. 
  colnames(design) <- levels(pheno.f)
  
  cont.matrix <- makeContrasts(contrasts = paste(groups, collapse = "-"), levels = design) #contrast is approx. log2(mean(Pos)) - log2(mean(Neg)) per gene. 
  
  if (is.null(GOI)){ 
    GOI <- 1:nrow(dge)
  }else{
    GOI <- intersect(rownames(dge), GOI)
    print(paste0("Length of GOI: ", length(GOI)))
  }
  
  if (logCPM){
    dge.norm <- cpm(dge, log=TRUE, prior.count = 1) #log2 + 1 CPM transformatio for normalization for sample to sample comparisons. 
    NormFactors <- "TMMCPM"
    
  }else if (all(!logCPM & !normalization)){
    dge.norm <- voom(dge, design, plot = FALSE) #can I use voom transformed values like CPM? yes
    NormFactors <- "Voom"  #voom transformed counts for sample to sample comparisons.
  
  }else if(all(!logCPM & normalization=="qt")){
    dge.norm <- voom(dge, design, plot = FALSE, normalize.method = "quantile")
    NormFactors <- "Voom.quantile" #voom and quantilte normalized counts for sample to sample comparisons.
  }

  print(NormFactors) #to confirm which type of DE is performed, trend or voom
  
  #fit the linear model. 
  print(lmMethod)
  fit <- lmFit(dge.norm, design,method=lmMethod)
  fit <- contrasts.fit(fit, contrasts = cont.matrix)
  
  #compute moderated t-statistics using empirical bayes moderation. 
  if(all(trend & logCPM)){ #only use limma trend method with CPM values, as per manual. 
    fit2 <- eBayes(fit,trend = trend, robust=eBayesRobust)[GOI,]
  }else{
    fit2 <- eBayes(fit, robust=eBayesRobust)[GOI,]  
  }

  # select differentially expressed genes.
  DE <-topTable(fit2,adjust.method="BH",sort.by="P",
                 number=20000,p.value=0.05, lfc=1) #abs(logFC) >= 1 for all genes

  list <- list(dge.norm,fit2, DE)
  names(list) <- c(NormFactors,"eBayesFit", "DE")
  

  return(list)
}
```


```{r}
coxSummaryTable <- function(coxph.res,Colname="Group"){
  c.mod <- coxph.res
  c.summ <- summary(coxph.res)
  c.table <- as.data.frame(c.summ$coefficients) %>% cbind(.,as.data.frame(c.summ$conf.int))
  # c.table
  c.HR <- round(c.table$`exp(coef)`, digits=3)
  c.CI <- paste(round(c.table$`lower .95`,digits=3),round(c.table$`upper .95`, digits = 3), sep="-")
  c.pVal <- round(c.table$`Pr(>|z|)`, digits=3)
  
  comp <- gsub("^.+(Yes|No|Unknown|High|Low)", "\\1",names(c.mod$coefficients))
  c.stats <- data.frame(names(c.mod$coefficients) ,comp, c.HR, c.CI, c.pVal)
  colnames(c.stats) <- c("Variable", Colname,"Hazard Ratio", "95% Confidence Interval", "P-value")
  # rownames(c.stats) <- names(c.mod$coefficients)
  
  return(c.stats)
}
```

```{r}

#Survival plot without gridlines. 
SurvivalPlot <- function(fit, LegendTitle, timeUnit,include.censored=TRUE, colors,pval=NULL,max.year=NULL){
  #fit the output of the survFit() function. 
  #legend title is a character vector which will be the plot legend title.
  #timeUnit is a character vector for the follow-up time in days, years, months etc. 
  #colors is a character vector the same length as the number of groups. 
  #max.year is the time (singe numeric) in years to end the plot at.
  #pval is string (charcter or numeric) of the p-value
  
  require(survival)
  library(ggplot2)
  library(GGally)
  
  if(is.null(pval)){
    pval <- ""
  }else{
    pval <- paste0("p = ",pval)
  }
  
  if(!is.null(max.year)){
    # if(max(fit$time) < max.year){
    pos.x <- max.year
    # }
  }else{
    pos.x <- max(fit$time)
  }
  
  if(is.null(fit$strata)){
    lm <- 1 #left margin (lm)
    rm <- 4  #right margin(rm)
    num.cols <- 1
    num.rows <- 1
    
    #main survival plot
    p <- ggsurv(fit, surv.col = colors,
                cens.col=colors, CI=FALSE, 
                lty.est = 1, size.est = 1.0,
                cens.size = 2.0,order.legend=FALSE)
    
  }else{
    
    m <- max(nchar(gsub("^.+\\=(.+)", "\\1", names(fit$strata)))) #maximum number of characters
    d <- length(fit$strata) #how many groups
    lm <- case_when(m <= 2 ~ 0.90,
                    m <= 5 ~ 1.25, 
                    m > 5 & m <= 9 ~ 1.7,
                    m > 9 & m < 13 ~ 2.6,
                    m >= 13 & m < 17 ~ 3.4,
                    m >= 17 & m < 21 ~ 5.0,
                    m >= 21 & m < 23 ~ 6.0,
                    m >= 23 & m < 25 ~ 6.5,
                    m >= 25 ~ 7.5)#left margin (lm)
    # print(c("km.plot", lm))
    rm <- case_when(d <= 4 ~ 1.5, d > 4 ~ 2.0) #right margin(rm)
    num.cols <- 2
    num.rows <- 2
    
    if(d > 4 & d < 7){
      num.rows <- 3
    }else if(d > 7 & d <= 18){
      num.cols <- 3
      num.rows <- 6
    }else if(d > 18){
      num.cols <- 5
      num.rows <- 5
    }
    
    if(num.cols*num.rows < d){
      num.rows <- 10
    }
    
    #main survival plot
    p <- ggsurv(fit, plot.cens=include.censored, 
                surv.col = colors, CI=FALSE, 
                lty.est = 1, size.est = 1.0,
                cens.size = 2.0,order.legend=FALSE)
  }
  
  #customize the plot
  p <- p + 
    labs(y= "Fraction Surviving", x = paste(timeUnit, "Follow-up")) + 
    scale_y_continuous(limits = c(0,1), 
                       breaks = seq(0,1,0.2),
                       minor_breaks = NULL) +
    scale_x_continuous(limits = c(0,pos.x),
                       breaks = seq(0,pos.x, 2)) +
    
    theme(plot.title = element_text(hjust = 0.5, size=10), 
          panel.background = element_rect(fill="white"), 
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(colour = "black", fill= NA, size=1.0),
          
          axis.text = element_text(colour = "black"),
          axis.text.y = element_text(size = 12),
          axis.text.x = element_text(size=12), 
          axis.title = element_text(size = 12), 
          legend.position = "top",
          legend.direction  = "horizontal",
          legend.margin = margin(0,0,0,0, unit = "pt"),
          legend.text = element_text(size=10),
          legend.title = element_text(size=10),
          legend.key=element_blank()) +
    
    theme(plot.margin = margin(0, rm,.5,lm,unit="cm")) +
    annotate(geom="text", x=1, y=0.05, label=pval, size=5) +
    guides(color=guide_legend(ncol=num.cols, nrow=num.rows))
  
  if (length(colors) > 1){
    p$scales$scales[[1]]$name <- LegendTitle
    p$scales$scales[[2]]$name <- LegendTitle
  }
  
  return(p)
}


#risk table dataframe 
risk.table <- function(survFit.obj, f.levels=NULL, 
                       times=NULL,col="black",
                       ret.data=FALSE, max.year=NULL){
  #survFit.obj is the results  survfit()
  #f.levels is an optional character vector to relevel the order of the groups, if desired. else levels is alphabetical
  #times would be a seperate numeric vector, with years/x-axis breaks points, if desired.  
  
  if(!is.null(max.year)){
    # if (max(survFit.obj$time) < max.year){
      times <- seq(0,max.year, by= 2)
      xlims <- max.year
    # }
  }else{
    times <- seq(0,max(survFit.obj$time), by= 2)
    xlims <- max(survFit.obj$time)
  }
  
  #Summary dataframe with the selected time points to get % OS/ EFS for plot x-axis
  summ <- summary(survFit.obj, times=times, extend=TRUE)
  
  
  if(is.null(f.levels)){
    f.levels <- unique(as.character(summ$strata)) %>%
      gsub("^.+\\=(.+)", "\\1", .)
  }
  
  #Create a new dataframe to hold the time,KM estimate and strata for plotting
  risk.df <- bind_cols(list(time=summ$time, 
                            surv=summ$surv,
                            n.risk=summ$n.risk, 
                            Group=as.character(summ$strata))) %>%
    set_colnames(c("time","surv","N.Risk","Group")) %>%
    mutate(Group=gsub("^.+\\=(.+)", "\\1", Group), 
           Group=factor(Group, levels = f.levels))
  
  
  if(ret.data){
    return(risk.df)
  }
  
  #variable for deciding length of margins. longer group names would need more space.
  m <- max(nchar(levels(risk.df$Group))) # print(c("length:", m))
  d <- length(levels(risk.df$Group))
  lm <- case_when(m <= 5 ~ 1.75, 
                  m > 5 & m <= 9 ~ 1.00, 
                  m > 9 & m <= 10 ~ 1.00, 
                  m > 10 & m < 13 ~ 1.10,
                  m >= 13 ~ 1.20) 

  rm <- case_when(d <= 5 ~ 1.5, 
                  m > 5 ~ 2.0) 

  
  #gglot the risk table (risk.df)
  tbl <- ggplot(risk.df, aes(x = time, y = Group, label=N.Risk)) +
    geom_text(size = 5)  +
    theme_bw()  +
    scale_x_continuous("Number at risk", 
                       limits = c(0,xlims),
                       breaks = times) +
    xlab(NULL) +
    ylab(NULL) +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          legend.position="none",
          axis.line = element_line(size=0.7, color="black"),
          axis.title.x = element_text(size=12),
          axis.ticks.x = element_blank(),
          axis.title.y = element_blank(),
          axis.text.x = element_blank(),
          axis.text.y = element_text(face="bold",
                                     size=12,
                                     color= col[levels(risk.df$Group)],
                                     hjust=1)) +
    #of note: this margin is still not perfect..... the size of window in Rstudio is different than what actually shows up on the tiff... 
    theme(plot.margin = margin(-1.5, rm, 0.1, lm, unit="cm"))
   

   
   
  return(tbl)
}
```

# Read in the Clincal Data

```{r}
host <- Sys.info()[["nodename"]]
if(grepl("gizmo", host)){
  FASTDRIVE <- "/fh/fast/meshinchi_s"
}else{
  FASTDRIVE <- "/Users/jsmi26/fast_drive" #/fh/fast/meshinchi_s on the Fred Hutch HPC
}

RPROJ <- list(PROJHOME=normalizePath(file.path(FASTDRIVE,"workingDir/TARGET/AML_TARGET/RNA/mRNAseq/analysis/")),
              CDE=normalizePath(file.path(FASTDRIVE, "workingDir/TARGET/AML_TARGET/Clinical/CDE/")),
              GENREFS=normalizePath(file.path(FASTDRIVE, "workingDir/TARGET/Reference_Data/")),
              TARGET=normalizePath(file.path(FASTDRIVE, "workingDir/TARGET/AML_TARGET/")),
              REFS=normalizePath(file.path(FASTDRIVE, "workingDir/0_For_Soheil/jlsmith3/reference_mapping-files/")),
              HOME=normalizePath(file.path(FASTDRIVE,"workingDir/0_For_Soheil/jlsmith3/RNA_seq_Analysis/")),
              SCRIPTS=normalizePath(file.path(FASTDRIVE,"workingDir/0_For_Soheil/jlsmith3/github_repos/")),
              # SWOG=normalizePath(file.path(FASTDRIVE,"workingDir/SWOG")), #directory has been moved somewhere?
              WORKINGDIR=normalizePath(file.path(FASTDRIVE,"workingDir/")))

attach(RPROJ)
rm(RPROJ)

PROJHOME <- file.path(PROJHOME,"2019.04.05_Kallisto_DE_Transcriptome_MS")
```

```{r}
CDE <- read.csv(file.path(PROJHOME,"manuscript/Supplemental_Tables/TARGET_AML_CDE_Supplement.09.13.21.csv")) %>% 
  mutate(Event.ID=ifelse(EFS.event.type.ID=="Censored", 0,1), 
         OS.ID=ifelse(OS.event.ID=="Alive", 0,1))


head(CDE)
dim(CDE) #1298   16
```

```{r}
table(CDE$Set)
```

# Read in the counts

```{r}
RBD <- readRDS(file.path(HOME,"0000.00.03_Expression_Matrices/TARGET_AML_RBD_Kallisto_Quant_GeneLevel_scaledTPM_counts.RDS"))
rownames(RBD) <- gsub("\\.[0-9]{1,}$", "", rownames(RBD))

head(RBD[,1:5])
dim(RBD) #59853  1462
```

# Read in the Gene Annotations

```{r}
IDmap <- read.csv(file.path(HOME,"0000.00.02_Reference_GeneInfo/gencode.v29_RepBase.v24.01_GeneLevel_IDmap_anno_12.23.19.csv"))

head(IDmap)
dim(IDmap)
```

```{r}
lncRNAs <- read.csv(file.path(HOME,"0000.00.02_Reference_GeneInfo/gencode.v29.lncRNAs_GeneLevel.IDmap.csv"), row.names = 1) %>% 
  set_rownames(.$gene_id)

# head(lncRNAs)
dim(lncRNAs)
```


# DE Results with AML vs NBM in training set

```{r}
NBM.cols <- colnames(RBD) %>% grep("^BM|^RO",., value = TRUE)
USIs <- CDE %>% 
  filter(Set=="Train") %>% 
  pull(USI)

train.cols <- c(NBM.cols,USIs)
p <- c(rep("NBM", length(NBM.cols)),
       rep("AML", length(USIs))) %>% 
  set_names(train.cols)

table(p)
```

```{r}
DE <- voom_DE(expnData = RBD[,train.cols],
              pheno = p,
              percent=0.01, #1%
              ref =  "NBM",
              GOI=lncRNAs$gene_id)

DE$DE <- DE$DE %>% 
  rownames_to_column("gene_id") %>% 
  right_join(., lncRNAs, by="gene_id") %>% 
  mutate(Comparison="AMLvsNBM") %>%
  filter(adj.P.Val < 0.05, abs(logFC) > 1.0) %>%
  arrange(desc(logFC))

dim(DE$Voom$E) #31406   848
dim(DE$DE) #1348    9
table(DE$DE$logFC > 1) #648 upreg
table(rownames(DE$Voom$E) %in% lncRNAs$gene_id) #7635 lncRNAs

# saveRDS(DE,file.path(PROJHOME,"Survival/Retrain/AML_vs_NBM_training_set_limma_DE.RDS"))
# write.csv(DE$DE, file.path(PROJHOME,"Survival/Retrain/AML_vs_NBM_training_set_limma_DEGs.csv"), row.names = F)
```


# Original Data 

```{r}
old <- read.csv(file.path(PROJHOME,"Survival/TraingSet_AMLvsNBM_DEGs.csv"))
dim(old)
# table(old$logFC > 1) #647 upreg

table(old$gene_id %in% DE$DE$gene_id) #there is 1 gene in the older analysis that is missing here
# old$gene_id[!old$gene_id %in% DE$DE$gene_id]
table(DE$DE$gene_id %in% old$gene_id)
```

```{r}
old_lncScore <- readRDS(file.path(PROJHOME, "Survival/00_Archive/TARGET_AML_RBD_lncRNAs_UV_upreg_pvalue_LT0.1_7.15.19.RDS"))

# table(DE$DE$gene_id %in% old_lncScore$nonZero.train.coef$gene) #OK
# names(old_lncScore)
dim(old_lncScore$Model.Comparison.df)

head(old_lncScore$Model.Comparison.df)
# table(old_lncScore$Model.Comparison.df$Set)
```

```{r}
old_CDE <- read.csv(file.path(PROJHOME,"Survival/TARGET_AML_RBD_lncRNAs_UV_upreg_pvalue_LT0.1_CDE_7.17.19.csv")) %>% 
  filter(Set != "Validation2") %>% 
  select(USI, matches("EFS.time|OS.time|Event|OS", ignore.case = FALSE)) %>% 
  rename_at(vars(First.Event:OS.ID), ~paste0(.,"_Original"))

# dim(old_CDE) #1300    7

new_CDE <- CDE %>% 
  select(USI, matches("EFS.time|OS.time|[Ee]vent|OS", ignore.case = FALSE)) %>% 
  rename_at(vars(EFS.time..days.:OS.ID), ~paste0(.,"_Retrain"))
# dim(new_CDE) #1298    7

compare <- old_CDE %>% 
  left_join(., new_CDE, by="USI") %>% 
  select(colnames(.)[order(colnames(.))]) %>% 
  select(USI, everything()) %>% 
  mutate(comp_EFS=EFS.time..days._Original==EFS.time..days._Retrain,
         comp_Event.ID=Event.ID_Original==Event.ID_Retrain)


# compare
table(compare$comp_EFS, useNA = 'always')
table(compare$comp_Event.ID, useNA = 'always')
```

```{r}
old_TMMCPM_train <- read.csv(file.path(PROJHOME,"Survival/TARGET_AML_RBD_TMMCPM_forModeling.csv"))

head(old_TMMCPM_train[,1:5])
dim(old_TMMCPM_train) #26157  1463
```

```{r}
table(rownames(DE$Voom$E) %in% old_TMMCPM_train$X) #All they are accounted for, but there are 5,000 additional genes!
```




# Train/Test/Val Subset Dataframes

The TMM method implements the trimmed mean of M-values proposed by Robinson and Oshlack (2010). By default, the M-values are weighted according to inverse variances, as computed by the delta method for logarithms of binomial random variables. If refColumn is unspecified, then the library whose upper quartile is closest to the mean upper quartile is used.

```{r}
sets <- unique(CDE$Set)
```

```{r}
#start with the expressed genes from the training set 
genes <- unique(rownames(DE$Voom$E))

# Then remove "low count genes" before normalization
#remove lowly expressed genes across the FULL cohort (AML Sets and NBM) to ensure that the selected genes are likely to be expressed in any AML subset/cohort (train, test, val). 
keep <- genes[rowSums(cpm(RBD[genes,]) >= 1) >= 0.05*ncol(RBD)]
RBD.lnc <- RBD[keep,] 
dim(RBD.lnc) #26157  1462
```

```{r}
table(rownames(RBD.lnc) %in% old_TMMCPM_train$X) # All previous genes are identified in the newer strategy's filtered expression
table(DE$DE$gene_id[DE$DE$logFC>1] %in% rownames(RBD.lnc))
table(rownames(RBD.lnc) %in% lncRNAs$gene_id) #5879 lncRNAs included 
incl <- intersect(DE$DE$gene_id[DE$DE$logFC>1], rownames(RBD.lnc))
length(incl)
table(incl %in% old_lncScore$nonZero.train.coef$gene) # all 37 model lncs are found 
```

```{r}
save=FALSE
cohorts <- purrr::map(sets,function(set){
  CDE.sub <- CDE[CDE$Set == set,]
  RBD.sub <- RBD.lnc[,CDE.sub$USI]
  #If refColumn is unspecified, then the column whose count-per-million upper quartile is closest to the mean upper quartile is set as the reference library.
  TMM.norm <- calcNormFactors(RBD.sub, method = 'TMM')
  lib.size <- colSums(RBD.sub)
  CPM.lnc <- cpm(RBD.sub,
                 lib.size = lib.size*TMM.norm,
                 log=TRUE,
                 prior.count = 0.5)
  if(save){
      write.csv(CPM.lnc,file=file.path(PROJHOME, paste0("Survival/Retrain/TARGET_AML_RBD_Kallisto_Quant_GeneLevel_",set,"_TMMCPM.csv")))
  }

  targets <- DE$DE %>%
      filter(grepl("^ENSG", gene_id), logFC > 1) %>% #remove Transposable elements, keep upregulated genes
      filter(gene_id %in% rownames(CPM.lnc)) %>%
      pull(gene_id)
  
  # print(length(targets)) #410 lncRNAs
  CDE.sub %>%
    left_join(.,CPM.lnc[targets,] %>%
                t() %>%
                as.data.frame() %>%
                rownames_to_column("USI"),
              by="USI") %>% 
    set_rownames(.$USI)
})
names(cohorts) <- sets
```

```{r}
sapply(cohorts, dim)
lapply(cohorts, head)
# table(CDE$Event.ID)
```

# Compare Original Expression Values

```{r}
train_TMMCPM <- read.csv("data/TARGET_AML_RBD_Kallisto_Quant_GeneLevel_Train_TMMCPM.csv")
# old_TMMCPM_train[,c("X",cohorts$Train$USI[1:10])]
# train_TMMCPM[,c("X",cohorts$Train$USI[1:10])]
dim(train_TMMCPM)
```

```{r}
diffs_training <- train_TMMCPM[,cohorts$Train$USI] - old_TMMCPM_train[,cohorts$Train$USI]
mean_expn_training <- colMeans(train_TMMCPM[,cohorts$Train$USI])

diffs_training_clean <- diffs_training %>% 
  mutate(gene_id=train_TMMCPM$X) %>% 
  pivot_longer(cols=-gene_id, 
               names_to = "USI", 
               values_to = "difference") %>% 
  mutate(Set="Training Set")

head(diffs_training_clean)
# head(mean_expn_training)
# length(mean_expn_training)
```

```{r fig.height=3, fig.width=3}
# pdf("Trainging_set_expression_differences_hist.pdf", height = 10, width = 7)
ggplot(diffs_training_clean, aes(x=difference)) +
  geom_histogram(binwidth = 0.005, fill="dodgerblue4") +
  # geom_boxplot(outlier.size = 1, alpha=0.5, fill="dodgerblue") +
  labs(x="Difference in Normalized Gene Expression (CPM)") +
  scale_x_continuous(limits = c(-0.1, 0.1)) +
  theme_bw()
# dev.off()
```

```{r}
diffs_training_summary <- diffs_training_clean %>% 
  group_by(USI) %>% 
  summarize(mean_diff=mean(difference),
            sd_difference=sd(difference)) %>% 
  ungroup() %>% 
  mutate(mean_expn=mean_expn_training,
         mean_expn_min=mean_expn-abs(mean_diff), 
         mean_expn_max=mean_expn+abs(mean_diff),
         group="training_set") %>% 
         # size_group=ifelse(abs(mean_difference)> 0.05, "Difference > 0.05 CPM", "Difference < 0.05 CPM")) %>% 
  arrange(desc(mean_expn)) %>% 
  mutate(USI=factor(USI, levels=USI))


# dim(diffs_training_summary)
head(diffs_training_summary)
# tail(diffs_training_summary)
# table(diffs_training_summary$size_group)
# quantile(diffs_training_summary$mean_difference)
#the 75th percentile is < 0.001 CPM different 
```

```{r}
pdf("figures/Trainging_set_expression_differences_ribbon.pdf", height = 7, width = 10)

ggplot(diffs_training_summary, aes(x=USI, y=mean_expn, group=group)) +
  geom_ribbon(aes(ymax=mean_expn_max, ymin=mean_expn_min),
              fill="dodgerblue",
              alpha=0.2) +
  geom_point(size=0.5,
             color="dodgerblue4") +
  labs(y="Mean Normalized Gene Expression (CPM)",
       x="Patient (Training Set") +
  theme_classic() +
  theme(axis.title = element_text(size=16),
        axis.text.x = element_blank(),
        axis.text.y = element_text(size=16))

dev.off()
```

```{r fig.width=20, fig.height=10}
# pdf("Trainging_set_expression_differences_waterfall.pdf", height = 7, width = 20)

ggplot(diffs_training_summary, aes(x=USI, y=mean_difference)) +
  geom_col(fill="dodgerblue4") +
  scale_y_continuous(limits = c(-0.1, 0.1)) +
  labs(y="Difference in Normalized Gene Expression (CPM)",
       x="Patient (Training Set") +
  theme_classic() +
  theme(axis.title = element_text(size=16),
        axis.text.x = element_blank(),
        axis.text.y = element_text(size=16))

# dev.off()
```


# Univariate survival Coxph regressions

```{r}
Genes <- grep("^ENSG[0-9]", colnames(cohorts$Train), value=TRUE)
  
ures <- lapply(Genes, cox_reg, CDE=cohorts$Train) %>% 
  bind_rows() %>% 
  dplyr::rename(P.Value="P-value",Hazard.Ratio="Hazard Ratio") %>% 
  mutate(Adj.P.value=p.adjust(P.Value, method = "BH")) %>%
  left_join(., select(DE$DE,gene_id,gene_name,
                      gene_type,matches("Comparison"),logFC,
                      FC.BH.PVal=adj.P.Val),
            by=c("Variable"="gene_id"))


sig.ures <- ures %>% 
  mutate(Sig.05=P.Value < 0.05, 
         Sig.10=P.Value < 0.1)  %>%
  filter(Sig.05 == TRUE | Sig.10 == TRUE) %>%
  arrange(desc(Hazard.Ratio))

dim(sig.ures) #141 univariate significantly associated 
# head(sig.ures)
```


# Model fit with LASSO Cox 

## LASSO for AML vs NBM DEGs

```{r}
uv_upreg_0.1 <- cox_glmnet_workflow(CDE.train = cohorts$Train, 
                              targets = filter(sig.ures, Comparison=="AMLvsNBM",logFC > 1, Sig.10) %>% 
                                         pull(Variable),
                              IDmap = lncRNAs, 
                              N.Groups = 4,
                              oneSE=FALSE,
                              CDE.validation1 = cohorts$Validation1,
                              CDE.validation2 = cohorts$Validation2)
```

```{r}
dim(uv_upreg_0.1$nonZero.train.coef) #47  4
# head(uv_upreg_0.1$nonZero.train.coef)
# saveRDS(uv_upreg_0.1,file.path(PROJHOME,"Survival/Retrain/retrained.RDS"))
```

```{r}
both_models <- full_join(uv_upreg_0.1$nonZero.train.coef,old_lncScore$nonZero.train.coef,
                         by="gene", suffix=c("_retrain","_original"))

dim(both_models)

# write.csv(both_models,"data/TARGET_AML_lncScore_retrained_coeffs.csv", row.names = FALSE)
```

```{r}
table(old_lncScore$nonZero.train.coef$gene %in% uv_upreg_0.1$nonZero.train.coef$gene) #36/37 lncRNAs are found in the 
```

```{r}
Model.Comparison.df <- uv_upreg_0.1$Model.Comparison.df %>% 
  select(USI, Set, lncScore.Group_Original=lncScore.Group,
         matches("lnc"), -Integrated.lncScore.CMrisk) %>% 
  rename_at(vars(matches("lnc\\.")), ~paste0(., "_retrain")) %>% 
  arrange(desc(lnc.Score_retrain)) %>%
  mutate(lncScore.Group_retrain=ifelse(lnc.Score_retrain > 0, "Pos", "Neg"),
         USI_factor=factor(USI, levels=USI))

head(Model.Comparison.df)

# quantile(Model.Comparison.df$lnc.Score_retrain)
#          0%         25%         50%         75%        100% 
# -1.76192829 -0.34540064 -0.00203548  0.31308612  1.48914410 


# write.csv(Model.Comparison.df, "data/TARGET_AML_lncScore_retrained.csv",row.names = FALSE)
```

```{r}
table(tolower(Model.Comparison.df$lncScore.Group_Original),
      Model.Comparison.df$lncScore.Group_retrain) 
```

```{r}
# pdf("figures/original_vs_retrained_model_lncScoreGroups_mosiacPlot.pdf",
#     height=7, width = 7)
tab <- table(tolower(Model.Comparison.df$lncScore.Group_Original),
                    Model.Comparison.df$lncScore.Group_retrain)
mosaicplot(x=tab,
      color=c("blue4","red4"),
      main="",cex.axis = 1.2,
      xlab = "Original Model: lncScore Groups",
      ylab = "Retrained Model: lncScore Groups")
# dev.off()
```

```{r}
Model.Comparison.df %>% 
  filter(lnc.Score_retrain > -0.00203548, 
         lnc.Score_retrain < 0.002)
```

```{r}
# pdf("figures/retrained_model_lncScoreGroups_lncScore_waterfallPlot.pdf", height = 5, width = 7)
ggplot(Model.Comparison.df, aes(x=USI_factor,y=lnc.Score_retrain)) +
  geom_col(fill="dodgerblue4") +
  facet_wrap(~Set, scales = 'free_x') +
  theme_classic()
# dev.off()
```

```{r}
hazard_ratios <- extract_metrics_df(uv_upreg_0.1$error.metrics,V=TRUE,V2=TRUE)
uv_upreg_0.1$AIC
```

```{r fig.height=7, fig.width=15}
p1 <- gridExtra::grid.arrange(grobs=c(uv_upreg_0.1$error.metrics$KM.EFS.Med[1:3],
                                uv_upreg_0.1$error.metrics$KM.EFS.Perc[1:3]), ncol=3, nrow=2) #%>% 
ggsave(plot=p1, filename = "figures/retrained_model_lncScore_median_EFS_KM_TrTeVal.pdf", 
       device = "pdf", units = "in", dpi=300, height = 7, width = 9)

p2 <- gridExtra::grid.arrange(grobs=c(uv_upreg_0.1$error.metrics$KM.OS.Med[1:3],
                                uv_upreg_0.1$error.metrics$KM.OS.Perc[1:3]), ncol=3, nrow=2) #%>% 
ggsave(plot=p2, filename = "figures/retrained_model_lncScore_quantile_OS_KM_TrTeVal.pdf", 
       device = "pdf", units = "in", dpi=300, height = 7, width = 9)

```


# Vary the Seed

```{r}
seeds <- ceiling(runif(20, min=5, max=1e6))

seeds
# write.csv(seeds,file = "seeds_09.26.2022.csv")
```

```{r}
varied_seed <- purrr::map(seeds, function(s){
  cox_glmnet_workflow(CDE.train = cohorts$Train, 
                              targets = filter(sig.ures, Comparison=="AMLvsNBM",logFC > 1, Sig.10) %>% 
                                         pull(Variable),
                              IDmap = lncRNAs, 
                              N.Groups = 4,
                              seed_num = s,
                              oneSE=FALSE,
                              CDE.validation1 = cohorts$Validation1,
                              CDE.validation2 = cohorts$Validation2)
})
```


# Session Information 

```{r}
sessionInfo()
```



